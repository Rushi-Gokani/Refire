{%- comment -%}
  Changes made:
  - added id + type="button" to question button so aria-labelledby target exists and button doesn't submit forms
  - fixed CSS transition syntax (padding)
  - removed fixed `.open { max-height: 500px }` approach in favor of JS setting inline maxHeight using scrollHeight for smooth animation
  - ensured the script expects a <faq-accordion> wrapper (see example wrapper below)
{%- endcomment -%}

<!-- QUESTION BUTTON: note the id and type="button" -->
<button
  id="faq-question-{{ ai_gen_id }}"
  class="faq-question-{{ ai_gen_id }}"
  type="button"
  aria-expanded="{% if block.settings.open_by_default %}true{% else %}false{% endif %}"
  aria-controls="faq-answer-{{ ai_gen_id }}"
  data-faq-question>
  <span class="faq-question-text-{{ ai_gen_id }}">
    {{ block.settings.question | default: 'Add your question here' }}
  </span>
  <svg class="faq-chevron-{{ ai_gen_id }}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true" focusable="false">
    <path d="M6 9l6 6 6-6"/>
  </svg>
</button>

<!-- ANSWER -->
<div
  id="faq-answer-{{ ai_gen_id }}"
  class="faq-answer-{{ ai_gen_id }}{% if block.settings.open_by_default %} open{% endif %}"
  aria-hidden="{% if block.settings.open_by_default %}false{% else %}true{% endif %}"
  role="region"
  aria-labelledby="faq-question-{{ ai_gen_id }}">
  <div class="faq-answer-content-{{ ai_gen_id }}">
    {% if block.settings.answer != blank %}
      {{ block.settings.answer }}
    {% else %}
      <p>Add your answer here. You can include multiple paragraphs and formatting.</p>
    {% endif %}
  </div>
</div>

{%- style -%}
  /* fix: missing colon in transition, and keep class-based styles minimal */
  .faq-answer-{{ ai_gen_id }} {
    overflow: hidden;
    transition: max-height 0.28s ease, padding 0.28s ease;
    max-height: 0;
    padding: 0;
  }

  /* keep an "open" class for initial-server-render open state only;
     JS will manage inline max-height for animated transitions */
  .faq-answer-{{ ai_gen_id }}.open {
    /* when server-rendered open, ensure small padding — JS will override inline maxHeight */
    padding-bottom: 1.5rem;
  }
{%- endstyle -%}

<script>
(function() {
  // Only define once to avoid duplicate customElement errors
  if (!customElements.get('faq-accordion')) {
    class FaqAccordion extends HTMLElement {
      constructor() {
        super();
        // data-expand-mode can be "single" or "multi"
        this.expandMode = this.dataset.expandMode || 'multi';
        this.questions = [];
      }

      connectedCallback() {
        // collect only within this accordion instance
        this.questions = Array.from(this.querySelectorAll('[data-faq-question]'));
        this.setupEventListeners();
        this.setupKeyboardNavigation();
        // Set up initial open/closed heights for any server-rendered .open items
        this.questions.forEach((q) => {
          const answer = q.nextElementSibling;
          if (!answer) return;
          if (q.getAttribute('aria-expanded') === 'true') {
            // set inline maxHeight to allow smooth transition if user then toggles
            answer.style.maxHeight = answer.scrollHeight + 'px';
            answer.style.paddingBottom = window.innerWidth <= 749 ? '1.25rem' : '1.5rem';
            answer.setAttribute('aria-hidden', 'false');
          } else {
            answer.style.maxHeight = null;
            answer.style.paddingBottom = '0';
            answer.setAttribute('aria-hidden', 'true');
          }
        });
      }

      setupEventListeners() {
        this.questions.forEach((question, index) => {
          question.addEventListener('click', () => this.toggleAnswer(question, index));
        });
      }

      setupKeyboardNavigation() {
        this.questions.forEach((question, index) => {
          question.addEventListener('keydown', (e) => {
            switch (e.key) {
              case 'ArrowDown':
                e.preventDefault();
                this.focusNext(index);
                break;
              case 'ArrowUp':
                e.preventDefault();
                this.focusPrevious(index);
                break;
              case 'Home':
                e.preventDefault();
                this.focusFirst();
                break;
              case 'End':
                e.preventDefault();
                this.focusLast();
                break;
              case 'Enter':
              case ' ':
                e.preventDefault();
                this.toggleAnswer(question, index);
                break;
            }
          });
        });
      }

      toggleAnswer(question, index) {
        const isExpanded = question.getAttribute('aria-expanded') === 'true';
        const answer = question.nextElementSibling;
        if (!answer) return;

        if (this.expandMode === 'single' && !isExpanded) {
          // close others
          this.closeAllAnswers();
        }

        // toggle attributes
        question.setAttribute('aria-expanded', isExpanded ? 'false' : 'true');
        answer.setAttribute('aria-hidden', isExpanded ? 'true' : 'false');

        // animate using scrollHeight for reliable height
        if (isExpanded) {
          // currently open -> close
          // set maxHeight to current height (forces computed), then to 0
          answer.style.maxHeight = answer.scrollHeight + 'px';
          // allow the browser a frame to pick up the starting value
          requestAnimationFrame(() => {
            answer.style.maxHeight = '0';
            answer.style.paddingBottom = '0';
          });
        } else {
          // currently closed -> open
          answer.style.maxHeight = answer.scrollHeight + 'px';
          answer.style.paddingBottom = window.innerWidth <= 749 ? '1.25rem' : '1.5rem';
          // after transition remove maxHeight so future content changes can expand naturally
          const clear = () => {
            answer.style.maxHeight = answer.scrollHeight + 'px'; // keep it stable
            answer.removeEventListener('transitionend', clear);
            // set explicit maxHeight to scrollHeight so it stays opened — you can remove this if you prefer
          };
          answer.addEventListener('transitionend', clear);
        }
      }

      closeAllAnswers() {
        this.questions.forEach(question => {
          const answer = question.nextElementSibling;
          if (!answer) return;
          question.setAttribute('aria-expanded', 'false');
          answer.setAttribute('aria-hidden', 'true');
          // animate closing
          answer.style.maxHeight = answer.scrollHeight + 'px';
          requestAnimationFrame(() => {
            answer.style.maxHeight = '0';
            answer.style.paddingBottom = '0';
          });
        });
      }

      focusNext(currentIndex) {
        const nextIndex = (currentIndex + 1) % this.questions.length;
        this.questions[nextIndex].focus();
      }

      focusPrevious(currentIndex) {
        const prevIndex = currentIndex === 0 ? this.questions.length - 1 : currentIndex - 1;
        this.questions[prevIndex].focus();
      }

      focusFirst() {
        this.questions[0].focus();
      }

      focusLast() {
        this.questions[this.questions.length - 1].focus();
      }
    }

    customElements.define('faq-accordion', FaqAccordion);
  }
})();
</script>

{% schema %}
{
  "name": "FAQ item",
  "settings": [
    {
      "type": "text",
      "id": "question",
      "label": "Question",
      "default": "What is your return policy?"
    },
    {
      "type": "richtext",
      "id": "answer",
      "label": "Answer",
      "default": "<p>We offer a 30-day return policy for all unused items in their original packaging. Please contact our customer service team to initiate a return.</p>"
    },
    {
      "type": "checkbox",
      "id": "open_by_default",
      "label": "Open by default",
      "default": false
    },
    {
      "type": "header",
      "content": "Color overrides"
    },
    {
      "type": "color",
      "id": "heading_color",
      "label": "Question color"
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Answer color"
    }
  ]
}
{% endschema %}

